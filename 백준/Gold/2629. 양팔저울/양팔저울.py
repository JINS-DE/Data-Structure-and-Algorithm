'''
주어진 추를 모두 겨처 무게를 만드는 방법 3가지
1. 추의 무게를 더한다
2. 추의 무게를 뺀다.
3. 추를 사용하지 않는다.

해결방안
- 완전탐색 문제 느낌이다. dp를 이용해 공간을 사고 시간을 줄여보자.
    - 추가 저울에 올라올 모든 경우의 수를 고려해야 한다.
    - 그 중에서 중복되는 것들은 dp를 이용해 제거해보자.
- 추의 서로 간의 무게의 차이를 알면 구슬의 무게를 판별할 수 있다.
    ex) 30g, 20g추가 있다하자
        1. 30g과 20g의 구슬의 무게를 판별할 수 있다.
        2. 30g과 20g의 차이인 10g 구슬의 무게를 판별할 수 있다. 
- 중복 제외하기
    - 양쪽 저울의 무게차이가 같고 추의 리스트에서 탐색한 index의 수가 같으면 중복

생각하기
- 구슬 리스트 for문 돌려서 dp[n][구슬의 무게]==1 이면 정답 아니면 오답

# 작은 예시로 살펴보기
n = 2 (두 개의 추가 있음)
w = [2, 3] (첫 번째 추의 무게는 2, 두 번째 추의 무게는 3)

초기 호출: cal(0, 0)

현재 무게: 0
아직 추를 사용하지 않았으므로 num = 0

cal(0, 0)
├── cal(1, 2)  [첫 번째 추 사용, 왼쪽에 추가]
│   ├── cal(2, 5)  [두 번째 추 사용, 왼쪽에 추가]
│   ├── cal(2, 2)  [두 번째 추 사용 안함]
│   └── cal(2, 1)  [두 번째 추 사용, 오른쪽에 추가]
├── cal(1, 0)  [첫 번째 추 사용 안함]
│   ├── cal(2, 3)  [두 번째 추 사용, 왼쪽에 추가]
│   ├── cal(2, 0)  [두 번째 추 사용 안함]
│   └── cal(2, 3)  [두 번째 추 사용, 오른쪽에 추가]
└── cal(1, 2)  [첫 번째 추 사용, 오른쪽에 추가]
    ├── cal(2, 5)  [두 번째 추 사용, 왼쪽에 추가]
    ├── cal(2, 2)  [두 번째 추 사용 안함]
    └── cal(2, 1)  [두 번째 추 사용, 오른쪽에 추가]

'''
import sys
input=sys.stdin.readline
# 추의 개수 / 무게 리스트
n, w = int(input()), list(map(int, input().split())) 
# 구슬의 개수 / 무게 리스트
m, b = int(input()), list(map(int, input().split()))

# dp 초기화 : 추의 최대 무게가 500g 이고 추의 개수는 n개이다. => 최대 나올 수 있는 추의 무게는 500*n
dp = [[0 for _ in range((500 * j)+1)] for j in range(n+1)]
ans = []

def cal(num, weight): # 추로 판별할 수 있는 구슬의 무게를 나타내는 함수
    if num > n: # 구슬의 숫자가 주어진 구슬보다 크다면 return
        return
    if dp[num][weight] == 1: # 이미 같은 추의 무게와 개수로 방문했다면 return
        return
    dp[num][weight] = 1
    cal(num+1, weight + w[num-1])# 추 넣기
    cal(num+1, weight)# 추를 추가하지 않고 그대로 진행
    cal(num+1, abs(weight - w[num-1]))# 추 다른쪽에 넣기 (무게빼기)
cal(0, 0)

for bead in b:
    if bead > 500 * n:
        ans.append('N')
    elif dp[n][bead] == 1:
        ans.append('Y')
    else:
        ans.append('N')

print(*ans)



